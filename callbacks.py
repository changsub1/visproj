
from dash.dependencies import Input, Output, State, ALL
from dash import html, dcc, dash
import dash_bootstrap_components as dbc
import pandas as pd
import numpy as np
import plotly.express as px
import sqlite3
import glob
import os

# ÌîÑÎ°úÏ†ùÌä∏Ïùò Îã§Î•∏ ÌååÏùºÏóêÏÑú Ìï®ÏàòÎì§ÏùÑ Í∞ÄÏ†∏ÏòµÎãàÎã§.
from data_collector import collect_and_save_data
from visualizations import create_matplotlib_figure, fig_to_base64, create_brand_rank_chart

def register_callbacks(app):
    # 1. Îç∞Ïù¥ÌÑ∞ ÏàòÏßë Î∞è Ïä§ÌÇ§Îßà ÌëúÏãú ÏΩúÎ∞±
    @app.callback(
        Output('collection-status-output', 'children'),
        Input('start-collection-button', 'n_clicks'),
        State('api-url-input', 'value'),
        State('db-name-input', 'value'),
        State('start-year-input', 'value'),
        State('end-year-input', 'value'),
        State('delay-input', 'value'),
        prevent_initial_call=True
    )
    def handle_data_collection(n_clicks, api_url, db_name, start_year, end_year, delay):
        if not all([api_url, db_name, start_year, end_year, delay is not None]):
            return "API URL, DB ÌååÏùº Ïù¥Î¶Ñ, ÏãúÏûë/Ï¢ÖÎ£å Ïó∞ÎèÑ, ÏßÄÏó∞ ÏãúÍ∞ÑÏùÑ Î™®Îëê ÏûÖÎ†•Ìï¥Ï£ºÏÑ∏Ïöî."

        # Îç∞Ïù¥ÌÑ∞ ÏàòÏßë Ìï®Ïàò Ìò∏Ï∂ú
        log_output = collect_and_save_data(api_url, db_name, start_year, end_year, delay)

        # ÏÑ±Í≥µÏ†ÅÏúºÎ°ú ÏàòÏßëÎêòÏóàÎäîÏßÄ ÌôïÏù∏
        if "ÏÑ±Í≥µ!" in log_output:
            try:
                if not db_name.endswith('.db'):
                    db_name += '.db'
                table_name = os.path.splitext(db_name)[0]

                conn = sqlite3.connect(db_name)
                
                # 1. Ïä§ÌÇ§Îßà Ï†ïÎ≥¥ Í∞ÄÏ†∏Ïò§Í∏∞
                schema_df = pd.read_sql_query(f'PRAGMA table_info("{table_name}")', conn)
                schema_table = dbc.Table.from_dataframe(
                    schema_df[['name', 'type']], 
                    striped=True, bordered=True, hover=True,
                    header=['ÏπºÎüºÎ™Ö', 'Îç∞Ïù¥ÌÑ∞ ÌÉÄÏûÖ']
                )

                # 2. ÏÉòÌîå Îç∞Ïù¥ÌÑ∞ Í∞ÄÏ†∏Ïò§Í∏∞
                sample_df = pd.read_sql_query(f'SELECT * FROM "{table_name}" LIMIT 5', conn)
                sample_table = dbc.Table.from_dataframe(
                    sample_df, striped=True, bordered=True, hover=True, responsive=True
                )
                
                conn.close()

                # ÏµúÏ¢Ö Í≤∞Í≥ºÎ¨º Ï°∞Ìï©
                return html.Div([
                    html.Pre(log_output),
                    html.Hr(),
                    html.H4("üìã DB Ïä§ÌÇ§Îßà Ï†ïÎ≥¥"),
                    schema_table,
                    html.Hr(),
                    html.H4("üìä ÏÉòÌîå Îç∞Ïù¥ÌÑ∞ (ÏÉÅÏúÑ 5Í∞ú)"),
                    sample_table
                ])

            except Exception as e:
                return html.Div([
                    html.Pre(log_output),
                    html.Hr(),
                    dbc.Alert(f"DB Ï†ïÎ≥¥ Ï°∞Ìöå Ï§ë Ïò§Î•ò Î∞úÏÉù: {e}", color="danger")
                ])
        
        # Ïã§Ìå® Ïãú Î°úÍ∑∏Îßå Î∞òÌôò
        return html.Pre(log_output)

    # 2. Îç∞Ïù¥ÌÑ∞ÏÖã ÎìúÎ°≠Îã§Ïö¥ Î©îÎâ¥ ÏóÖÎç∞Ïù¥Ìä∏ ÏΩúÎ∞±
    @app.callback(
        Output('dataset-dropdown', 'options'),
        Input('main-tabs', 'active_tab')
    )
    def update_dataset_dropdown(tab_id):
        if tab_id == 'tab-visualize':
            db_files = glob.glob('*.db')
            return [{'label': os.path.basename(f), 'value': f} for f in db_files]
        return []

    # 3. ÏóëÏÖÄ Îã§Ïö¥Î°úÎìú Î≤ÑÌäº ÌôúÏÑ±Ìôî/ÎπÑÌôúÏÑ±Ìôî
    @app.callback(
        Output('download-excel-button', 'disabled'),
        Input('dataset-dropdown', 'value')
    )
    def toggle_download_button(db_file):
        return db_file is None

    # 4. ÏóëÏÖÄ ÌååÏùº Îã§Ïö¥Î°úÎìú
    @app.callback(
        Output('download-excel', 'data'),
        Input('download-excel-button', 'n_clicks'),
        State('dataset-dropdown', 'value'),
        prevent_initial_call=True
    )
    def download_excel_file(n_clicks, db_file):
        if not db_file:
            return None
        
        excel_path = os.path.splitext(db_file)[0] + '.xlsx'
        if not os.path.exists(excel_path):
            return None 
            
        return dcc.send_file(excel_path)

    # 5. Í≥ÑÏ∏µ ÌïÑÌÑ∞ Î†àÏù¥ÏïÑÏõÉ ÏÉùÏÑ± (ÏßÅÏ†ë Ïó∞Í≤∞ Î∞©Ïãù)
    @app.callback(
        Output('h-filter-container-0', 'children'),
        Output('h-filter-container-1', 'children'),
        Output('h-filter-container-2', 'children'),
        Output('h-filter-container-3', 'children'),
        Output('h-filter-container-4', 'children'),
        Output('h-filter-cols', 'data'),
        Input('dataset-dropdown', 'value'),
        prevent_initial_call=True
    )
    def generate_filters_layout(db_file):
        if not db_file:
            return [None] * 5 + [None]

        try:
            conn = sqlite3.connect(db_file)
            table_name = os.path.splitext(os.path.basename(db_file))[0]
            df_schema = pd.read_sql_query(f'SELECT * FROM "{table_name}" LIMIT 1', conn)

            h_cols = []
            for col in df_schema.columns:
                is_numeric = pd.api.types.is_numeric_dtype(df_schema[col].dtype)
                if is_numeric and col != 'yr':
                    break
                h_cols.append(col)
                if len(h_cols) >= 5:
                    break
            
            filters = [None] * 5
            for i, col in enumerate(h_cols):
                options = []
                if i == 0:
                    query = f'SELECT DISTINCT "{col}" FROM "{table_name}" ORDER BY "{col}" DESC' if col == 'yr' else f'SELECT DISTINCT "{col}" FROM "{table_name}" ORDER BY "{col}" ASC'
                    options_df = pd.read_sql_query(query, conn)
                    options = [{'label': opt, 'value': opt} for opt in options_df[col].dropna()]

                filters[i] = html.Div([
                    dbc.Label(col),
                    dcc.Dropdown(id=f'h-filter-{i}', options=options, multi=True, placeholder=f'{col} ÏÑ†ÌÉù...'),
                    html.Br()
                ])
            
            conn.close()
            return filters[0], filters[1], filters[2], filters[3], filters[4], h_cols
        except Exception as e:
            print(f"ÌïÑÌÑ∞ Î†àÏù¥ÏïÑÏõÉ ÏÉùÏÑ± Ïò§Î•ò: {e}")
            return [None] * 5 + [None]

    # 6. Ïó∞Í≥Ñ ÌïÑÌÑ∞ ÏΩúÎ∞± Ï≤¥Ïù∏ (ÏµúÎåÄ 5Îã®Í≥Ñ)
    def create_cascading_callback(level):
        @app.callback(
            Output(f'h-filter-{level}', 'options'),
            Output(f'h-filter-{level}', 'value'),
            Input(f'h-filter-{level-1}', 'value'),
            [State(f'h-filter-{j}', 'value') for j in range(level-1)],
            State('dataset-dropdown', 'value'),
            State('h-filter-cols', 'data'),
            prevent_initial_call=True
        )
        def update_options(parent_value, *args):
            # *argsÎ•º ÏÇ¨Ïö©ÌïòÏó¨ Î™®Îì† State Ïù∏ÏûêÎ•º ÌäúÌîåÎ°ú Î∞õÏùå
            # ÎßàÏßÄÎßâ Îëê Ïù∏ÏûêÎäî db_file, h_colsÎ°ú Í≥†Ï†ïÎê®
            db_file = args[-2]
            h_cols = args[-1]
            grandparent_values = args[:-2]

            if not parent_value or not db_file or not h_cols or level >= len(h_cols):
                return [], None

            conn = sqlite3.connect(db_file)
            table_name = os.path.splitext(os.path.basename(db_file))[0]
            current_col = h_cols[level]

            all_parent_vals = list(grandparent_values) + [parent_value]
            
            where_clauses = []
            params = []
            for i, val_list in enumerate(all_parent_vals):
                if val_list:
                    col_name = h_cols[i]
                    placeholders = ', '.join('?' for _ in val_list)
                    where_clauses.append(f'"{col_name}" IN ({placeholders})')
                    params.extend(val_list)

            query = f'SELECT DISTINCT "{current_col}" FROM "{table_name}"'
            if where_clauses:
                query += " WHERE " + " AND ".join(where_clauses)
            query += f' ORDER BY "{current_col}" ASC'

            try:
                df = pd.read_sql_query(query, conn, params=params)
                options = [{'label': i, 'value': i} for i in df[current_col].dropna()]
                return options, None
            finally:
                conn.close()
        return update_options

    for i in range(1, 5):
        create_cascading_callback(i)

    # 7. Ï∞®Ìä∏ ÎπåÎçî ÏòµÏÖò ÏóÖÎç∞Ïù¥Ìä∏
    @app.callback(
        Output('chart-builder-xaxis', 'options'),
        Output('chart-builder-yaxis', 'options'),
        Output('chart-builder-group', 'options'),
        Input('dataset-dropdown', 'value'),
        prevent_initial_call=True
    )
    def update_chart_builder_options(db_file):
        if not db_file:
            return [], [], []
        
        conn = sqlite3.connect(db_file)
        table_name = os.path.splitext(os.path.basename(db_file))[0]
        df = pd.read_sql_query(f'SELECT * FROM "{table_name}" LIMIT 5', conn)
        conn.close()

        numeric_cols = df.select_dtypes(include=np.number).columns.tolist()
        categorical_cols = df.select_dtypes(exclude=np.number).columns.tolist()

        cat_options = [{'label': col, 'value': col} for col in categorical_cols]
        num_options = [{'label': col, 'value': col} for col in numeric_cols]
        
        return cat_options, num_options, cat_options

    # 8. ÏµúÏ¢Ö Í∑∏ÎûòÌîÑ ÏÉùÏÑ± ÏΩúÎ∞±
    @app.callback(
        Output('visualization-graph', 'figure'),
        Input('update-graph-button', 'n_clicks'),
        State('dataset-dropdown', 'value'),
        # Chart builder states
        State('chart-builder-chart-type', 'value'),
        State('chart-builder-xaxis', 'value'),
        State('chart-builder-yaxis', 'value'),
        State('chart-builder-agg', 'value'),
        State('chart-builder-group', 'value'),
        State('chart-builder-top-n', 'value'), # Top N Ï∂îÍ∞Ä
        # Filter states
        State('h-filter-cols', 'data'),
        [State(f'h-filter-{i}', 'value') for i in range(5)],
        prevent_initial_call=True
    )
    def update_graph_final(n_clicks, db_file, chart_type, xaxis, yaxis, agg, group, top_n, h_cols, filter_values):
        if not all([db_file, chart_type, xaxis, agg]):
            return px.bar(title="Ï∞®Ìä∏ ÎπåÎçîÏùò Î™®Îì† ÌïÑÏàò Ìï≠Î™©(Ï∞®Ìä∏ Ï¢ÖÎ•ò, XÏ∂ï, YÏ∂ï ÏßëÍ≥Ñ Î∞©Ïãù)ÏùÑ ÏÑ†ÌÉùÌï¥Ï£ºÏÑ∏Ïöî.")
        
        if agg != 'count' and not yaxis:
            return px.bar(title="'Í∞úÏàò(Count)'Í∞Ä ÏïÑÎãå ÏßëÍ≥Ñ Î∞©ÏãùÏóêÎäî YÏ∂ïÏùÑ Î∞òÎìúÏãú ÏÑ†ÌÉùÌï¥Ïïº Ìï©ÎãàÎã§.")

        # 1. Îç∞Ïù¥ÌÑ∞ Î°úÎìú Î∞è ÌïÑÌÑ∞ÎßÅ
        conn = sqlite3.connect(db_file)
        table_name = os.path.splitext(os.path.basename(db_file))[0]
        df = pd.read_sql_query(f'SELECT * FROM "{table_name}"', conn)
        conn.close()

        if h_cols:
            for i, vals in enumerate(filter_values):
                if vals and i < len(h_cols):
                    col_name = h_cols[i]
                    df = df[df[col_name].isin(vals)]
        
        if df.empty:
            return px.bar(title="ÌïÑÌÑ∞ Í≤∞Í≥ºÏóê Ìï¥ÎãπÌïòÎäî Îç∞Ïù¥ÌÑ∞Í∞Ä ÏóÜÏäµÎãàÎã§.")

        # 2. Îç∞Ïù¥ÌÑ∞ ÏßëÍ≥Ñ
        group_by_cols = [xaxis]
        if group and group != xaxis:
            group_by_cols.append(group)
        
        try:
            if agg == 'count':
                agg_df = df.groupby(group_by_cols).size().reset_index(name='count')
                yaxis = 'count'
            else:
                agg_df = df.groupby(group_by_cols)[yaxis].agg(agg).reset_index()
        except Exception as e:
            return px.bar(title=f"Îç∞Ïù¥ÌÑ∞ ÏßëÍ≥Ñ Ï§ë Ïò§Î•ò Î∞úÏÉù: {e}")

        # 3. Ï†ïÎ†¨ Î∞è ÏÉÅÏúÑ NÍ∞ú ÏÑ†ÌÉù
        # ÌååÏù¥ Ï∞®Ìä∏Í∞Ä ÏïÑÎãê Í≤ΩÏö∞ÏóêÎßå Ï†ïÎ†¨ Ï†ÅÏö©
        if chart_type != 'pie':
            agg_df = agg_df.sort_values(by=yaxis, ascending=False)
            if top_n and top_n > 0:
                agg_df = agg_df.head(top_n)

        # 4. Ï∞®Ìä∏ ÏÉùÏÑ±
        try:
            title = f'{xaxis} Î≥Ñ {yaxis} {agg} Î∂ÑÏÑù'
            if top_n and top_n > 0:
                title += f' (ÏÉÅÏúÑ {top_n}Í∞ú)'

            if chart_type == 'bar':
                fig = px.bar(agg_df, x=xaxis, y=yaxis, color=group, barmode='group', title=title)
            elif chart_type == 'line':
                fig = px.line(agg_df, x=xaxis, y=yaxis, color=group, title=title)
            elif chart_type == 'pie':
                if group: # ÌååÏù¥Ï∞®Ìä∏Îäî Í∑∏Î£πÌôî ÎØ∏ÏßÄÏõê
                    return px.bar(title="ÌååÏù¥ Ï∞®Ìä∏Îäî Í∑∏Î£πÌôî(ÏÉâÏÉÅ) Í∏∞Îä•ÏùÑ ÏßÄÏõêÌïòÏßÄ ÏïäÏäµÎãàÎã§.")
                # ÌååÏù¥Ï∞®Ìä∏Îäî ÏÉÅÏúÑ NÍ∞ú Î°úÏßÅÏùÑ Îã§Î•¥Í≤å Ï†ÅÏö©Ìï¥Ïïº Ìï† Ïàò ÏûàÏùå (Ïó¨Í∏∞ÏÑúÎäî ÏßëÍ≥Ñ ÌõÑ Ï†ÑÏ≤¥ ÎπÑÏú® ÌëúÏãú)
                pie_df = df.groupby(xaxis)[yaxis].agg(agg).reset_index()
                if top_n and top_n > 0:
                    pie_df = pie_df.sort_values(by=yaxis, ascending=False).head(top_n)
                fig = px.pie(pie_df, names=xaxis, values=yaxis, title=title)
            else:
                fig = px.bar(title="Ïïå Ïàò ÏóÜÎäî Ï∞®Ìä∏ Ï¢ÖÎ•ò")
        except Exception as e:
            return px.bar(title=f"Ï∞®Ìä∏ ÏÉùÏÑ± Ï§ë Ïò§Î•ò Î∞úÏÉù: {e}")

        return fig
